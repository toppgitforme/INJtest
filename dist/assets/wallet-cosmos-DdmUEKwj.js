const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-BoD-kmKC.js","assets/icons-Dj0zHVqu.js","assets/hash-C5AeYnZ0.js","assets/injective-utils-C9MYzl-J.js","assets/wallet-other-DeBqkjrb.js","assets/injective-sdk-yGcRIHv8.js","assets/wallet-core-CdETWVBX.js","assets/injective-networks-BywkriB7.js","assets/index-BEkJg0WA.js"])))=>i.map(i=>d[i]);
import{b7 as C,b8 as I,b2 as O,ba as k,bb as P,a_ as K,bc as W,b5 as _}from"./injective-sdk-yGcRIHv8.js";import{Q as s,K as l,U as c,T as d,e as m,W as B,G as D}from"./injective-utils-C9MYzl-J.js";import{a as M,W as r,c as x,d as h,e as w,h as N,j as b}from"./wallet-core-CdETWVBX.js";import"./icons-Dj0zHVqu.js";import"./injective-networks-BywkriB7.js";let f=null;const j=async()=>(f||(f=(await _(async()=>{const{SigningStargateClient:n}=await import("./index-BoD-kmKC.js").then(t=>t.i);return{SigningStargateClient:n}},__vite__mapDeps([0,1,2,3,4,5,6,7,8]))).SigningStargateClient),f);function u(n){"@babel/helpers - typeof";return u=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},u(n)}function L(n,t){if(u(n)!="object"||!n)return n;var e=n[Symbol.toPrimitive];if(e!==void 0){var o=e.call(n,t);if(u(o)!="object")return o;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(n)}function G(n){var t=L(n,"string");return u(t)=="symbol"?t:t+""}function p(n,t,e){return(t=G(t))in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}const v=()=>typeof window<"u"?window:{};var S=class A{constructor({wallet:t,chainId:e}){p(this,"wallet",void 0),p(this,"chainId",void 0),this.wallet=t,this.chainId=e}async isChainIdSupported(t){const{wallet:e}=this;return new A({chainId:t,wallet:e}).checkChainIdSupport()}async getCosmosWallet(){const{chainId:t}=this,e=this.getCosmos();try{return await e.enable(t),e}catch(o){throw new s(new Error(o.message))}}async chainNotSupported(){const{chainId:t,wallet:e}=this,o=t.split("-"),a=e===r.Keplr?"https://chains.keplr.app/":e===r.OWallet?"https://owallet.io/":void 0;throw new s(new Error(`${l(e)} may not support ${o[0]||t} network. Please check if the chain can be added.`),a?{context:a}:{})}async getAccounts(){const{chainId:t}=this,e=this.getCosmos();try{return e.getOfflineSigner(t).getAccounts()}catch(o){throw new s(new Error(o.message),{contextModule:B.GetAccounts})}}async getKey(){const{wallet:t,chainId:e}=this,o=await this.getCosmosWallet();try{return o.getKey(e)}catch(a){throw new s(new Error(a.message),{contextModule:t})}}async getOfflineSigner(t){const{wallet:e}=this;try{return this.getCosmos().getOfflineSigner(t||this.chainId)}catch(o){throw new s(new Error(o.message),{contextModule:e})}}async getOfflineAminoSigner(){const{chainId:t,wallet:e}=this;if(![r.Keplr,r.OWallet].includes(e))throw new s(new Error(`getOfflineAminoSigner is not support on ${l(e)}`));const o=await this.getCosmosWallet();try{return o.getOfflineSignerOnlyAmino(t)}catch(a){throw new s(new Error(a.message),{context:e})}}async broadcastTx(t){const{chainId:e,wallet:o}=this,a=await this.getCosmosWallet();try{const i=await a.sendTx(e,W.toBinary(t),b.Sync);if(!i||i.length===0)throw new d(new Error("Transaction failed to be broadcasted"),{contextModule:o});return C(i)}catch(i){throw i instanceof d?i:new s(new Error(i.message),{context:"broadcast-tx",contextModule:o})}}async broadcastTxBlock(t){const{chainId:e,wallet:o}=this,a=await this.getCosmosWallet();try{const i=await a.sendTx(e,W.toBinary(t),b.Block);if(!i||i.length===0)throw new d(new Error("Transaction failed to be broadcasted"),{contextModule:o});return C(i)}catch(i){throw i instanceof d?i:new s(new Error(i.message),{context:"broadcast-tx",contextModule:o})}}async signAndBroadcastAminoUsingCosmjs(t,e,o){const{chainId:a,wallet:i}=this,g=await this.getCosmosWallet();if(![r.Keplr,r.OWallet].includes(i))throw new s(new Error(`signAndBroadcastAminoUsingCosmjs is not support on ${l(i)}`));if(!o.rpc)throw new D(new Error("Please provide rpc endpoint"));const y=await j(),E=g.getOfflineSignerOnlyAmino(a),[T]=await E.getAccounts();return await(await y.connectWithSigner(o.rpc,E)).signAndBroadcast(T.address,t,e)}async signArbitrary({data:t,signer:e}){const{chainId:o,wallet:a}=this,i=await this.getCosmosWallet();if(![r.Keplr,r.Cosmostation].includes(a))throw new s(new Error(`signArbitrary is not supported on ${l(a)}`));try{return(await i.signArbitrary(o,e,t)).signature}catch(g){throw new s(new Error(g.message),{context:a,contextModule:"sign-arbitrary"})}}async signEIP712CosmosTx({eip712:t,signDoc:e}){const{chainId:o,wallet:a}=this,i=await this.getCosmosWallet(),g=await this.getKey();try{return i.experimentalSignEIP712CosmosTx_v0(o,g.bech32Address,t,e)}catch(y){throw new s(new Error(y.message),{context:a,contextModule:"sign-eip712-cosmos-tx"})}}async checkChainIdSupport(){const{chainId:t,wallet:e}=this,o=t.split("-");if(e===r.Cosmostation)return this.checkCosmostationChainSupport();const a=this.getCosmos();try{return!!await a.getKey(t)}catch{throw new s(new Error(`${l(e)} doesn't support ${o[0]||t} network. Please use another Cosmos wallet`))}}async checkCosmostationChainSupport(){var t;const{chainId:e}=this,o=v(),a=e.split("-");if(!(!((t=o.cosmostation)===null||t===void 0)&&t.cosmos))throw new s(new Error("Please install the Cosmostation extension"),{code:c,type:m.WalletNotInstalledError,contextModule:r.Cosmostation});try{if(!(await o.cosmostation.cosmos.request({method:"cos_supportedChainIds"})).official.includes(e))throw new s(new Error(`Cosmostation doesn't support ${a[0]||e} network. Please use another Cosmos wallet`));return!0}catch(i){throw i instanceof s?i:new s(new Error(i.message))}}getCosmos(){const{wallet:t}=this,e=v();if(!e)throw new s(new Error(`Please install ${l(t)} extension`),{code:c,type:m.WalletNotInstalledError,contextModule:t});let o;if(t===r.OWallet&&(o=e.owallet),t===r.Keplr&&(o=e.keplr),t===r.Ninji&&(o=e.ninji),t===r.Leap&&(o=e.leap),t===r.Cosmostation){var a;o=(a=e.cosmostation)===null||a===void 0||(a=a.providers)===null||a===void 0?void 0:a.keplr}if(!o)throw new s(new Error(`Please install ${l(t)} extension`),{code:c,type:m.WalletNotInstalledError,contextModule:t});return o}async disableGasCheck(){const{wallet:t}=this,e=await this.getCosmosWallet();if(![r.Keplr,r.OWallet].includes(t))throw new s(new Error(`disableGasCheck is not support on ${l(t)}`));e.defaultOptions={...e.defaultOptions,sign:{...e.defaultOptions.sign,disableBalanceCheck:!0}}}async enableGasCheck(){const{wallet:t}=this,e=await this.getCosmosWallet();if(![r.Keplr,r.OWallet].includes(t))throw new s(new Error(`EnableGasCheck is not support on ${l(t)}`));e.defaultOptions={...e.defaultOptions,sign:{...e.defaultOptions.sign,disableBalanceCheck:!1}}}};const $=[r.Leap,r.Ninji,r.Keplr,r.OWallet];var z=class extends M{constructor(n){if(super({...n,chainId:n.chainId}),p(this,"wallet",void 0),p(this,"cosmosWallet",void 0),!$.includes(n.wallet))throw new s(new Error(`Cosmos Wallet for ${l(n.wallet)} is not supported.`));this.wallet=n.wallet,this.chainId=n.chainId,this.cosmosWallet=new S({wallet:n.wallet,chainId:n.chainId})}async getWalletDeviceType(){return(await this.getCurrentCosmosWallet().getKey()).isNanoLedger?Promise.resolve(x.Hardware):Promise.resolve(x.Browser)}async enable(){return await this.getCurrentCosmosWallet().checkChainIdSupport()}async disconnect(){const{wallet:n}=this;this.listeners[h.AccountChange]&&(n===r.Ninji&&window.ninji.off("accountsChanged",this.listeners[h.AccountChange]),[r.Keplr,r.OWallet].includes(n)&&window.removeEventListener("keplr_keystorechange",this.listeners[h.AccountChange]),n===r.Leap&&window.removeEventListener("leap_keystorechange",this.listeners[h.AccountChange]),n===r.Cosmostation&&window.removeEventListener("cosmostation_keystorechange",this.listeners[h.AccountChange])),this.listeners={}}async getAddresses(){const n=this.getCurrentCosmosWallet();try{return(await n.getAccounts()).map(t=>t.address)}catch(t){throw new s(new Error(t.message),{code:c,context:w.GetAccounts})}}async getAddressesInfo(){throw new s(new Error("getAddressesInfo is not implemented"),{code:c,context:w.GetAccounts})}async getSessionOrConfirm(n){return Promise.resolve(`0x${C(I(`Confirmation for ${n} at time: ${Date.now()}`))}`)}async sendEvmTransaction(n,t){const{wallet:e}=this;throw new s(new Error(`sendEvmTransaction is not supported. ${l(e)} only supports sending cosmos transactions`),{code:c,context:w.SendEvmTransaction})}async sendTransaction(n,t){const e=this.getCurrentCosmosWallet(),o=O(n);if(!t.endpoints)throw new s(new Error("You have to pass endpoints within the options to broadcast transaction"));try{return await k(await e.broadcastTx(o),t)}catch(a){throw a instanceof d?a:new d(new Error(a.message),{code:c,context:w.SendTransaction})}}async signAminoCosmosTransaction(n){const t=await this.getCurrentCosmosWallet().getOfflineAminoSigner();try{return await t.signAmino(n.address,n.signDoc)}catch(e){throw new s(new Error(e.message),{code:c,context:w.SignTransaction})}}async signCosmosTransaction(n){const t=await this.getCurrentCosmosWallet().getOfflineSigner(this.chainId),e=P(n);try{if(!("signDirect"in t))throw new s(new Error("signDirect not available"),{code:c,context:w.SendTransaction});return await t.signDirect(n.address,N(e))}catch(o){throw new s(new Error(o.message),{code:c,context:w.SendTransaction})}}async signEip712TypedData(n,t){throw new s(new Error("This wallet does not support signing Evm transactions"),{code:c,context:w.SendTransaction})}async signArbitrary(n,t){const e=this.getCurrentCosmosWallet();try{return await e.signArbitrary({data:t,signer:n})}catch(o){throw new s(new Error(o.message),{code:c,context:w.SignArbitrary})}}async getEthereumChainId(){const{wallet:n}=this;throw new s(new Error(`getEthereumChainId is not supported on ${l(n)}`),{code:c,context:w.GetChainId})}async getEvmTransactionReceipt(n){const{wallet:t}=this;throw new s(new Error(`getEvmTransactionReceipt is not supported on ${l(t)}`),{code:c,context:w.GetEvmTransactionReceipt})}async getPubKey(){return K((await this.getCurrentCosmosWallet().getKey()).pubKey)}async onAccountChange(n){const{wallet:t}=this,e=async()=>{const[o]=await this.getAddresses();n(o)};this.listeners={[h.AccountChange]:e},t===r.Ninji&&window.ninji.on("accountsChanged",e),[r.Keplr,r.OWallet].includes(t)&&window.addEventListener("keplr_keystorechange",e),t===r.Leap&&window.addEventListener("leap_keystorechange",e),t===r.Cosmostation&&window.addEventListener("cosmostation_keystorechange",e)}getCosmosWallet(n){const{wallet:t,cosmosWallet:e}=this;return e||new S({chainId:n,wallet:t})}async getOfflineSigner(n){const t=await this.getCosmosWallet(n||this.chainId);if(!t)throw new Error("no cosmos wallet");return await t.getOfflineSigner(n||this.chainId)}getCurrentCosmosWallet(){const{wallet:n,cosmosWallet:t}=this;if(!t)throw new s(new Error(`Please install the ${l(n)} wallet extension`),{code:c,type:m.WalletNotInstalledError,context:w.SignTransaction});return t}};export{S as CosmosWallet,z as CosmosWalletStrategy};
