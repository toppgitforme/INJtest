const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/Eth-CLtoRhLg-DeAxrFLU.js","assets/injective-utils-C9MYzl-J.js","assets/icons-Dj0zHVqu.js","assets/lib-es-BdVxwK9Z-B9dpt8vi.js","assets/semver-DQp6anwM-IwHLRqB3.js","assets/hash-C5AeYnZ0.js","assets/Cosmos-Cn09F7ch-Dquyx2QU.js","assets/TransportWebUSB-CfDDfqrP-C9OKahqw.js","assets/lib-es-DZEyST3--mHrXDXPA.js","assets/TransportWebHID-BHzJV7La-DufEEiZt.js","assets/index-B7jbZLBE.js","assets/injective-sdk-yGcRIHv8.js","assets/index-BEkJg0WA.js","assets/wallet-other-DeBqkjrb.js","assets/wallet-core-CdETWVBX.js","assets/injective-networks-BywkriB7.js"])))=>i.map(i=>d[i]);
import{b7 as S,b8 as F,aQ as k,a_ as U,aL as he,bd as ue,b9 as q,a$ as W,s as b,b5 as O,be as ge,bf as we,bg as ae,bh as re,t as f,bi as pe,bj as te,bk as R}from"./injective-sdk-yGcRIHv8.js";import{V as _,e as h,U as i,Q as M,x as T,T as V,X as E,G as ne,Y as v}from"./injective-utils-C9MYzl-J.js";import{a as Z,D as J,c as Y,e as d,k as Q,l as A,m as x,n as B,f as se}from"./wallet-core-CdETWVBX.js";const G={LedgerLive:"ledger-live",LedgerMew:"ledger-mew"},me={Ledger:"ledger",LedgerCosmos:"ledger-cosmos",LedgerLegacy:"ledger-legacy"},ye=e=>{const a=e.publicKey;return ae(S(re(a,!0)))};var ve=class{wallets=[];ledger;constructor(e){this.ledger=e,this.wallets=[]}async getWallets(e,t){const{start:a,end:r}=this.getOffset();return(!this.hasWallets()||!this.hasWalletsInOffset(a))&&await this.getWalletsBasedOnIndex({start:a,end:r,baseDerivationPath:e,derivationPathType:t}),this.wallets.slice(a,r)}getLedgerDerivationPathBasedOnType=({fullBaseDerivationPath:e,derivationPathType:t,index:a})=>t===G.LedgerLive?`${e}/${a}'/0/0`:`${e}/0'/${a}`;async getWalletsBasedOnIndex({start:e,end:t,baseDerivationPath:a,derivationPathType:r}){for(let n=e;n<t;n+=1){const s=this.getLedgerDerivationPathBasedOnType({fullBaseDerivationPath:a,derivationPathType:r,index:n}),c=await this.ledger.getAddress(s),o={publicKey:W(c.publicKey),chainCode:c.chainCode?W(c.chainCode):new Uint8Array(32)},g=c.address||ye(o);this.wallets.push({hdKey:o,baseDerivationPath:a,address:g.toLowerCase(),derivationPath:s})}}hasWallets(){return this.wallets.length>0}hasWalletsInOffset(e){return this.wallets.length>e}getOffset(){const e=this.wallets.length;return{start:e,end:e+A}}hasWalletForAddress(e){return this.wallets.find(t=>t.address.toLowerCase()===e.toLowerCase())!==void 0}async getWalletForAddress(e){return this.wallets.find(t=>t.address.toLowerCase()===e.toLowerCase())}reset(){this.wallets=[]}};let H,K,N,j;async function fe(){return H||(H=(await O(async()=>{const{default:e}=await import("./Eth-CLtoRhLg-DeAxrFLU.js");return{default:e}},__vite__mapDeps([0,1,2,3,4,5]))).default),H}async function Te(){return K||(K=(await O(async()=>{const{default:e}=await import("./Cosmos-Cn09F7ch-Dquyx2QU.js");return{default:e}},__vite__mapDeps([6,3,1,2]))).default),K}async function ie(){return N||(N=(await O(async()=>{const{default:e}=await import("./TransportWebUSB-CfDDfqrP-C9OKahqw.js");return{default:e}},__vite__mapDeps([7,3,4,1,2,8]))).default),N}async function oe(){return j||(j=(await O(async()=>{const{default:e}=await import("./TransportWebHID-BHzJV7La-DufEEiZt.js");return{default:e}},__vite__mapDeps([9,3,4,1,2,8]))).default),j}var Pe=class D{ledger=null;accountManager=null;static async getTransport(){const t=await ie(),a=await oe();try{if(await a.isSupported()){const r=await a.list();if(r.length>0&&r[0].opened)return new a(r[0]);const n=await a.openConnected().catch(()=>null);return n||await a.request()}if(await t.isSupported()){const r=await t.openConnected().catch(()=>null);return r||await t.request()}}catch(r){throw new E(new Error(r.message))}return t.request()}async getInstance(){const t=await fe();if(!this.ledger){const a=await D.getTransport();this.ledger=new t(a),a.on("disconnect",()=>{this.ledger=null,this.accountManager=null})}return this.ledger}async getAccountManager(){return this.accountManager||(this.accountManager=new ve(await this.getInstance())),this.accountManager}async refresh(){return this.ledger?(this.ledger.transport.close(),new D):new D}},Ee=class{ledger;derivationPath;address;chainId;constructor(e,t){this.ledger=e,this.derivationPath=t.derivationPath||"m/44'/60'/0'/0/0",this.chainId=parseInt(t.chainId||"1")}async getClient(){return B({chainId:this.chainId,account:await this.getAddress()})}async setChainId(e){this.chainId=parseInt(e.replace("0x",""),16)}async getAddress(){if(!this.address){const{address:e}=await(await this.ledger.getInstance()).getAddress(this.derivationPath);this.address=e}return this.address}async signTypedData(e){const t=await(await this.ledger.getInstance()).signEIP712Message(this.derivationPath,JSON.parse(e)),a=t.v.toString(16).padStart(2,"0"),r=`${t.r}${t.s}${a}`;return r.startsWith("0x")?r:`0x${r}`}async signTransaction(e){const t=await this.ledger.getInstance(),a=b(e),r=await t.clearSignTransaction(this.derivationPath,a.substring(2),{erc20:!0,externalPlugins:!0,nft:!0});return b(e,{r:r.r,s:r.s,v:BigInt(r.v)})}async signMessage(e){const t=await(await this.ledger.getInstance()).signPersonalMessage(this.derivationPath,e),a=t.v.toString(16).padStart(2,"0"),r=`${t.r}${t.s}${a}`;return r.startsWith("0x")?r:`0x${r}`}getChain(){return se(this.chainId)}async request(e){if(e.method==="eth_requestAccounts")return[await this.getAddress()];if(e.method==="eth_sign"){if(!e.params[0])throw new Error("Missing parameter for eth_sign");return this.signMessage(e.params[0])}if(e.method==="eth_signTransaction"){if(!e.params[0])throw new Error("Missing parameter for eth_signTransaction");return this.signTransaction(e.params[0])}if(e.method==="eth_signTypedData"){if(!e.params[0])throw new Error("Missing parameter for eth_signTypedData");return this.signTypedData(e.params[0])}if(e.method==="eth_chainId")return`0x${this.chainId.toString(16)}`;if(e.method==="wallet_switchEthereumChain")return this.setChainId(e.params[0]?.chainId||"0x1");if(e.method==="eth_estimateGas"){const t=x(this.chainId),a={to:e.params[0].to,value:e.params[0].value,data:e.params[0].data,account:await this.getAddress()};return`0x${(await t.estimateGas(a)).toString(16)}`}if(e.method==="eth_getTransactionCount"){if(!e.params)throw new Error("params is required");return`0x${(await x(this.chainId).getTransactionCount({address:await this.getAddress(),blockTag:"pending"})).toString(16)}`}if(e.method==="eth_sendTransaction"){const t=await this.getAddress(),a=B({chainId:this.chainId,account:t}),r=await a.prepareTransactionRequest({...e.params[0]}),n=await this.signTransaction(r);return await a.sendRawTransaction({serializedTransaction:n})}return(await this.getClient()).request({method:e.method,params:e.params})}on(e,t){throw new Error("Method not implemented.")}once(e,t){throw new Error("Method not implemented.")}removeListener(e,t){throw new Error("Method not implemented.")}off(e,t){throw new Error("Method not implemented.")}};const Ie=e=>ge({domain:e.domain,types:e.types}),Ce=e=>we({data:e.message,types:e.types,primaryType:e.primaryType});function _e(e){const t={MAX_TOTAL_SIZE:8e3,MAX_MSGS_SIZE:4e3,MAX_CONTEXT_SIZE:2e3,MAX_NESTING_DEPTH:3,MAX_MESSAGE_COUNT:3};try{if(JSON.stringify(e).length>t.MAX_TOTAL_SIZE)return!0;if(e.message?.msgs){if(e.message.msgs.length>t.MAX_MSGS_SIZE)return!0;try{const n=JSON.parse(e.message.msgs);if(Array.isArray(n)&&n.length>t.MAX_MESSAGE_COUNT)return!0;for(const s of n)if(s.msg&&typeof s.msg=="string"&&(s.msg.match(/\\\\/g)||[]).length>10)return!0}catch{}}return!!(e.message?.context&&e.message.context.length>t.MAX_CONTEXT_SIZE)}catch{return!0}}var ce=class extends Z{baseDerivationPath;derivationPathType;ledger;evmOptions;publicClient;constructor(e){super(e),this.baseDerivationPath=J,this.derivationPathType=e.derivationPathType,this.ledger=new Pe,this.evmOptions=e.evmOptions}setMetadata(e){this.metadata=e}async getWalletDeviceType(){return Promise.resolve(Y.Hardware)}async enable(){return Promise.resolve(!0)}async disconnect(){this.ledger=await this.ledger.refresh()}async getDerivationPath(e){return this.metadata?.derivationPath?this.metadata.derivationPath:(await this.getWalletForAddress(e)).derivationPath}async getAddresses(){const{baseDerivationPath:e,derivationPathType:t}=this;try{return(await(await this.ledger.getAccountManager()).getWallets(e,t)).map(a=>a.address)}catch(a){throw new E(new Error(a.message),{code:i,type:h.WalletError,contextModule:d.GetAccounts})}}async getAddressesInfo(){const{baseDerivationPath:e,derivationPathType:t}=this;try{return(await(await this.ledger.getAccountManager()).getWallets(e,t)).map(a=>({address:a.address,derivationPath:a.derivationPath,baseDerivationPath:a.baseDerivationPath}))}catch(a){throw new E(new Error(a.message),{code:i,type:h.WalletError,contextModule:d.GetAccounts})}}async getSessionOrConfirm(e){return Promise.resolve(`0x${S(F(`Confirmation for ${e} at time: ${Date.now()}`))}`)}async sendEvmTransaction(e,t){const a=await this.signEvmTransaction(e,t);try{return await(await this.getPublicClient(t.evmChainId)).sendRawTransaction({serializedTransaction:a})}catch(r){throw new E(new Error(r.message),{code:i,type:h.WalletError,contextModule:d.SendEvmTransaction})}}async sendTransaction(e,t){const{endpoints:a,txTimeout:r}=t;if(!a)throw new T(new Error("You have to pass endpoints.grpc within the options for using Ethereum native wallets"));const n=await new k(a.grpc).broadcast(e,{txTimeout:r});if(n.code!==0)throw new V(new Error(n.rawLog),{code:i,contextCode:n.code,contextModule:n.codespace});return n}async signEip712TypedData(e,t){const a=await this.getDerivationPath(t),r=JSON.parse(e);if(_e(r))return this.signEIP712HashedMessage(a,r);try{const n=await(await this.ledger.getInstance()).signEIP712Message(a,r);return this.formatSignatureResult(n)}catch(n){const s=n.message;if(!(s.includes("instruction not supported")||s.includes("invalid status")||s.includes("not supported")||s.includes("INS_NOT_SUPPORTED")))throw new E(new Error(s),{code:i,type:h.WalletError,contextModule:d.SignTransaction});return this.signEIP712HashedMessage(a,r)}}async signEIP712HashedMessage(e,t){try{const a=await(await this.ledger.getInstance()).signEIP712HashedMessage(e,Ie(t),Ce(t));return this.formatSignatureResult(a)}catch(a){throw new E(new Error(a.message),{code:i,type:h.WalletError,contextModule:d.SignTransaction})}}formatSignatureResult(e){const t=e.v.toString(16).padStart(2,"0"),a=`${e.r}${e.s}${t}`;return a.startsWith("0x")?a:`0x${a}`}async signAminoCosmosTransaction(e){throw new T(new Error("This wallet does not support signing Cosmos transactions"),{code:i,type:h.WalletError,contextModule:d.SendTransaction})}async signCosmosTransaction(e){throw new T(new Error("This wallet does not support signing Cosmos transactions"),{code:i,type:h.WalletError,contextModule:d.SendTransaction})}async signArbitrary(e,t){try{const a=await this.getDerivationPath(e),r=await(await this.ledger.getInstance()).signPersonalMessage(a,S(F(q(t))));return this.formatSignatureResult(r)}catch(a){throw new E(new Error(a.message),{code:i,type:h.WalletError,contextModule:d.SignTransaction})}}async getEthereumChainId(){return(await(await this.getPublicClient()).getChainId()).toString()}async getEvmTransactionReceipt(e,t){const a=await this.getPublicClient(t);try{return await a.waitForTransactionReceipt({hash:e,timeout:3e4,pollingInterval:3e3}),e}catch{throw new Error(`Failed to retrieve transaction receipt for txHash: ${e}`)}}async getPubKey(){throw new T(new Error("You can only fetch PubKey from Cosmos native wallets"))}async signEvmTransaction(e,t){const a=await this.getPublicClient(t.evmChainId),r=parseInt(t.evmChainId.toString(),10),n=t.address.startsWith("0x")?t.address:`0x${t.address}`,s=await a.getTransactionCount({address:n}),c=l=>{if(typeof l=="string"){const u=l.startsWith("0x")?l:`0x${l}`;return BigInt(u)}return BigInt(l)},o={type:"eip1559",chainId:r,nonce:s,to:e.to,value:c(e.value||"0x0"),data:e.data,gas:c(e.gas),maxFeePerGas:c(e.maxFeePerGas),maxPriorityFeePerGas:c(e.maxPriorityFeePerGas)},g=b(o).slice(2);try{const l=await this.ledger.getInstance(),u=await this.getDerivationPath(t.address),p=await l.clearSignTransaction(u,g,{erc20:!0,externalPlugins:!0,nft:!0});return b({...o,v:BigInt(`0x${p.v}`),r:`0x${p.r}`,s:`0x${p.s}`})}catch(l){throw new E(new Error(l.message),{code:i,type:h.WalletError,contextModule:d.SignEvmTransaction})}}async getWalletForAddress(e){if(this.metadata?.derivationPath)return{address:e,baseDerivationPath:this.metadata.baseDerivationPath||this.baseDerivationPath,derivationPath:this.metadata.derivationPath};try{const{baseDerivationPath:t,derivationPathType:a}=this,r=await this.ledger.getAccountManager();if(!r.hasWalletForAddress(e)){for(let n=0;n<Q/A;n+=1)if(await r.getWallets(t,a),r.hasWalletForAddress(e))return await r.getWalletForAddress(e)}return await r.getWalletForAddress(e)}catch(t){throw new E(new Error(t.message),{code:i,type:h.WalletError,contextModule:d.GetAccounts})}}async getEip1193Provider(){return new Ee(this.ledger,{chainId:this.evmOptions.evmChainId.toString(),derivationPath:this.metadata?.derivationPath})}async getPublicClient(e){if(this.publicClient)return this.publicClient;const t=this.evmOptions,a=e||t.evmChainId,r=t.rpcUrl||t.rpcUrls?.[a];if(!r)throw new ne(new Error("Please pass rpcUrl within the evmOptions"));return this.publicClient=x(a,r),this.publicClient}},Se=class extends ce{constructor(e){super({...e,derivationPathType:G.LedgerLive})}},be=class{wallets=[];ledger;constructor(t){this.ledger=t,this.wallets=[]}async getWallets(t){const{start:a,end:r}=this.getOffset();return(!this.hasWallets()||!this.hasWalletsInOffset(a))&&await this.getWalletsBasedOnIndex({start:a,end:r,baseDerivationPath:t}),this.wallets.slice(a,r)}getLedgerDerivationPathBasedOnType=({fullBaseDerivationPath:t,index:a})=>`${t}/${a}'/0/0`;async getWalletsBasedOnIndex({start:t,end:a,baseDerivationPath:r}){for(let n=t;n<a;n+=1){const s=this.getLedgerDerivationPathBasedOnType({fullBaseDerivationPath:r,index:n}),{address:c,publicKey:o}=await this.ledger.getAddress(s,"inj");this.wallets.push({publicKey:o,baseDerivationPath:r,address:c.toLowerCase(),derivationPath:s})}}hasWallets(){return this.wallets.length>0}hasWalletsInOffset(t){return this.wallets.length>t}getOffset(){const t=this.wallets.length;return{start:t,end:t+A}}hasWalletForAddress(t){return this.wallets.find(a=>a.address.toLowerCase()===t.toLowerCase())!==void 0}async getWalletForAddress(t){return this.wallets.find(a=>a.address.toLowerCase()===t.toLowerCase())}reset(){this.wallets=[]}},xe=class ${ledger=null;accountManager=null;static async getTransport(){const t=await ie(),a=await oe();try{if(await a.isSupported())return await a.create();if(await t.isSupported())return await a.create()}catch(r){throw new _(new Error(r.message))}return await a.create()}async getInstance(){const t=await Te();return this.ledger||(this.ledger=new t(await $.getTransport())),this.ledger}async getAccountManager(){return this.accountManager||(this.accountManager=new be(await this.getInstance())),this.accountManager}async refresh(){return this.ledger?(this.ledger.transport.close(),new $):new $}},Ae=class extends Z{baseDerivationPath;ledger;constructor(e){super(e),this.baseDerivationPath=J,this.ledger=new xe}async getWalletDeviceType(){return Promise.resolve(Y.Hardware)}async enable(){return Promise.resolve(!0)}async disconnect(){this.ledger=await this.ledger.refresh()}async getAddresses(){const{baseDerivationPath:e}=this;try{return(await(await this.ledger.getAccountManager()).getWallets(e)).map(t=>t.address)}catch(t){throw new _(new Error(t.message),{code:i,type:h.WalletError,contextModule:d.GetAccounts})}}async getAddressesInfo(){throw new _(new Error("getAddressesInfo is not implemented"),{code:i,type:h.WalletError,contextModule:d.GetAccounts})}async getSessionOrConfirm(e){return Promise.resolve(`0x${S(F(`Confirmation for ${e} at time: ${Date.now()}`))}`)}async sendEvmTransaction(e,t){throw new M(new Error("sendEvmTransaction is not supported. LedgerCosmos only supports sending cosmos transactions"),{code:i,context:d.SendEvmTransaction})}async sendTransaction(e,t){const{endpoints:a,txTimeout:r}=t;if(!a)throw new T(new Error("You have to pass endpoints.grpc within the options for using LedgerCosmos wallet"));const n=await new k(a.grpc).broadcast(e,{txTimeout:r});if(n.code!==0)throw new V(new Error(n.rawLog),{code:i,contextCode:n.code,contextModule:n.codespace});return n}async signAminoCosmosTransaction(e){try{const{derivationPath:t}=await this.getWalletForAddress(e.address);return{signed:void 0,signature:{signature:U((await(await this.ledger.getInstance()).sign(t,he(ue(e.signDoc)))).signature),pub_key:void 0}}}catch(t){throw new _(new Error(t.message),{code:i,type:h.WalletError,contextModule:d.SignTransaction})}}async signCosmosTransaction(e){throw new M(new Error("This wallet does not support signing using direct sign"),{code:i,context:d.SendTransaction})}async signEip712TypedData(e,t){throw new M(new Error("This wallet does not support signing Evm transactions"),{code:i,context:d.SendTransaction})}async signArbitrary(e,t){try{const{derivationPath:a}=await this.getWalletForAddress(e);return U((await(await this.ledger.getInstance()).sign(a,q(t))).signature)}catch(a){throw new _(new Error(a.message),{code:i,type:h.WalletError,contextModule:d.SignTransaction})}}async getEthereumChainId(){throw new M(new Error("getEthereumChainId is not supported on LedgerCosmos"),{code:i,context:d.GetChainId})}async getEvmTransactionReceipt(e){throw new M(new Error("getEvmTransactionReceipt is not supported on LedgerCosmos"),{code:i,context:d.GetEvmTransactionReceipt})}async getPubKey(e){if(!e)throw new T(new Error("You can only fetch PubKey corresponding to an address"));return U(W((await this.getWalletForAddress(e)).publicKey||""))}async getWalletForAddress(e){try{const{baseDerivationPath:t}=this,a=await this.ledger.getAccountManager();if(!a.hasWalletForAddress(e)){for(let r=0;r<Q/A;r+=1)if(await a.getWallets(t),a.hasWalletForAddress(e))return await a.getWalletForAddress(e)}return await a.getWalletForAddress(e)}catch(t){throw new _(new Error(t.message),{code:i,type:h.WalletError,contextModule:d.GetAccounts})}}},Me=class extends ce{constructor(e){super({...e,derivationPathType:G.LedgerMew})}};const Ke=Object.freeze(Object.defineProperty({__proto__:null,LedgerCosmosStrategy:Ae,LedgerDerivationPathType:G,LedgerLegacyStrategy:Me,LedgerLiveStrategy:Se,WalletLedger:me},Symbol.toStringTag,{value:"Module"})),z={Bip32:"bip32",Bip44:"bip44",Legacy:"legacy"};let X=null;async function P(){if(!X){var e;const t=await O(()=>import("./index-B7jbZLBE.js").then(a=>a.i),__vite__mapDeps([10,2,11,1,12,5,13,14,15]));X=(t==null||(e=t.default)===null||e===void 0?void 0:e.default)||t.default}return X}const de=(e,t=!0)=>{if(!t)throw new v(new Error("Trezor: Only version 4 of typed data signing is supported"));const{types:a,primaryType:r,domain:n,message:s}=pe(e),c=te("EIP712Domain",R(n),a).toString("hex");let o=null;return r!=="EIP712Domain"&&(o=te(r,R(s),{...a,domain:R(n)}).toString("hex")),{domain_separator_hash:c,message_hash:o,...e}};function L(e){"@babel/helpers - typeof";return L=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(t){return typeof t}:function(t){return t&&typeof Symbol=="function"&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},L(e)}function We(e,t){if(L(e)!="object"||!e)return e;var a=e[Symbol.toPrimitive];if(a!==void 0){var r=a.call(e,t);if(L(r)!="object")return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(e)}function ze(e){var t=We(e,"string");return L(t)=="symbol"?t:t+""}function w(e,t,a){return(t=ze(t))in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}const Le=e=>{const a=e.publicKey;return ae(S(re(a,!0)))};var Oe=class{constructor(){w(this,"wallets",[]),w(this,"getTrezorDerivationPathBasedOnType",({fullBaseDerivationPath:e,derivationPathType:t,index:a})=>t===z.Bip44?`${e}/${a}'/0/0`:t===z.Legacy?`m/${a}`:`${e}/0'/0/${a}`),this.wallets=[]}async getWallets(e,t){const{start:a,end:r}=this.getOffset();return(!this.hasWallets()||!this.hasWalletsInOffset(a))&&await this.getWalletsBasedOnIndex({start:a,end:r,baseDerivationPath:e,derivationPathType:t}),this.wallets.slice(a,r)}async getWalletsBasedOnIndex({start:e,end:t,baseDerivationPath:a,derivationPathType:r}){const n=await P(),s=[];for(let o=e;o<t;o+=1){const g=this.getTrezorDerivationPathBasedOnType({fullBaseDerivationPath:a,derivationPathType:r,index:o});s.push({path:g,showOnTrezor:!1})}const c=await n.ethereumGetPublicKey({bundle:s});if(!c.success)throw new v(new Error(c.payload&&c.payload.error||"Please make sure your Trezor is connected and unlocked"));for(const o of c.payload){const g={publicKey:W(o.publicKey),chainCode:W(o.chainCode)},l=Le(g);this.wallets.push({hdKey:g,derivationPath:o.serializedPath,address:l.toLowerCase()})}}hasWallets(){return this.wallets.length>0}hasWalletsInOffset(e){return this.wallets.length>e}getOffset(){const e=this.wallets.length;return{start:e,end:e+A}}hasWalletForAddress(e){return this.wallets.find(t=>t.address.toLowerCase()===e.toLowerCase())!==void 0}async getWalletForAddress(e){return this.wallets.find(t=>t.address.toLowerCase()===e.toLowerCase())}reset(){this.wallets=[]}};const De={email:"contact@injectivelabs.org",appUrl:"https://injectivelabs.org",appName:"Injective Labs"};var ee=class m{constructor(){w(this,"accountManager",null)}async connect(){if(m.initPromise)return m.initPromise;if(m.isInitialized)return Promise.resolve();m.initPromise=this.initializeTrezorConnect();try{await m.initPromise,m.isInitialized=!0}finally{m.initPromise=null}}async initializeTrezorConnect(){const t=await P();try{await t.init({manifest:De,coreMode:"popup",interactionTimeout:600})}catch(a){throw m.isInitialized=!1,a}}async getAccountManager(){return this.accountManager||(this.accountManager=new Oe),this.accountManager}static async reset(){if(m.isInitialized){var t;const a=await P();await((t=a.dispose)===null||t===void 0?void 0:t.call(a)),m.isInitialized=!1,m.initPromise=null}}};w(ee,"isInitialized",!1);w(ee,"initPromise",null);var $e=class{constructor(e,t){w(this,"trezor",void 0),w(this,"derivationPath",void 0),w(this,"address",void 0),w(this,"chainId",void 0),this.trezor=e,this.derivationPath=t.derivationPath||"m/44'/60'/0'/0/0",this.chainId=parseInt(t.chainId||"1")}async getClient(){return B({chainId:this.chainId,account:await this.getAddress()})}async setChainId(e){this.chainId=parseInt(e.replace("0x",""),16)}async getAddress(){if(!this.address){const e=await P();await this.trezor.connect();const t=await e.ethereumGetAddress({path:this.derivationPath,showOnTrezor:!1});if(!t.success)throw new Error(t.payload&&t.payload.error||"Failed to get address from Trezor");this.address=t.payload.address}return this.address}async signTypedData(e){const t=await P();await this.trezor.connect();const a=JSON.parse(e),{types:{EIP712Domain:r=[],...n}={},message:s={},domain:c={},primaryType:o,domain_separator_hash:g,message_hash:l}=de({...a,domain:{...a.domain,chainId:a.domain.chainId,salt:"0"}}),u=await t.ethereumSignTypedData({path:this.derivationPath,data:{types:{EIP712Domain:r,...n},message:s,domain:c,primaryType:o},message_hash:l,domain_separator_hash:g,metamask_v4_compat:!0});if("code"in u.payload&&u.payload.code==="Failure_ActionCancelled")throw new Error("Request rejected");if(!u.success)throw new Error(u.payload&&u.payload.error||"Unknown error");return u.payload.signature}async signTransaction(e){const t=await P();await this.trezor.connect();const a=u=>{if(typeof u=="string"){const p=u.startsWith("0x")?u:`0x${u}`;return BigInt(p)}return BigInt(u)},r=e.chainId||this.chainId,n=a(e.value||"0x0"),s=a(e.gas||e.gasLimit),c=a(e.maxFeePerGas),o=a(e.maxPriorityFeePerGas),g={to:e.to,value:f(n),gasLimit:f(s),nonce:f(e.nonce),data:e.data||"0x",chainId:r,maxFeePerGas:f(c),maxPriorityFeePerGas:f(o)},l=await t.ethereumSignTransaction({path:this.derivationPath,transaction:g});if(!l.success)throw new Error(l.payload&&l.payload.error||"Something happened while signing with Trezor");return b({type:"eip1559",chainId:r,nonce:e.nonce,to:e.to,value:n,data:e.data||"0x",gas:s,maxFeePerGas:c,maxPriorityFeePerGas:o,v:BigInt(l.payload.v),r:l.payload.r,s:l.payload.s})}async signMessage(e){const t=await P();await this.trezor.connect();const a=await t.ethereumSignMessage({path:this.derivationPath,message:e});if(!a.success)throw new Error(a.payload&&a.payload.error||"Unknown error");const r=a.payload.signature;return r.startsWith("0x")?r:`0x${r}`}getChain(){return se(this.chainId)}async request(e){if(e.method==="eth_requestAccounts")return[await this.getAddress()];if(e.method==="eth_sign"){if(!e.params[0])throw new Error("Missing parameter for eth_sign");return this.signMessage(e.params[0])}if(e.method==="eth_signTransaction"){if(!e.params[0])throw new Error("Missing parameter for eth_signTransaction");return this.signTransaction(e.params[0])}if(e.method==="eth_signTypedData"){if(!e.params[0])throw new Error("Missing parameter for eth_signTypedData");return this.signTypedData(e.params[0])}if(e.method==="eth_chainId")return`0x${this.chainId.toString(16)}`;if(e.method==="wallet_switchEthereumChain"){var t;return this.setChainId(((t=e.params[0])===null||t===void 0?void 0:t.chainId)||"0x1")}if(e.method==="eth_estimateGas"){const a=x(this.chainId),r={to:e.params[0].to,value:e.params[0].value,data:e.params[0].data,account:await this.getAddress()};return`0x${(await a.estimateGas(r)).toString(16)}`}if(e.method==="eth_getTransactionCount"){if(!e.params)throw new Error("params is required");return`0x${(await x(this.chainId).getTransactionCount({address:await this.getAddress(),blockTag:"pending"})).toString(16)}`}if(e.method==="eth_sendTransaction"){const a=await this.getAddress(),r=B({chainId:this.chainId,account:a}),n=await r.prepareTransactionRequest({...e.params[0]}),s=await this.signTransaction(n);return await r.sendRawTransaction({serializedTransaction:s})}return(await this.getClient()).request({method:e.method,params:e.params})}on(e,t){throw new Error("Method not implemented.")}once(e,t){throw new Error("Method not implemented.")}removeListener(e,t){throw new Error("Method not implemented.")}off(e,t){throw new Error("Method not implemented.")}},le=class extends Z{constructor(e){super(e),w(this,"baseDerivationPath",void 0),w(this,"trezor",void 0),w(this,"evmOptions",void 0),w(this,"publicClient",void 0),w(this,"derivationPathType",void 0),this.evmOptions=e.evmOptions,this.trezor=new ee,this.derivationPathType=e.derivationPathType,this.baseDerivationPath=J}setMetadata(e){this.metadata=e}async getWalletDeviceType(){return Promise.resolve(Y.Hardware)}async enable(){return Promise.resolve(!0)}async disconnect(){return Promise.resolve()}async getDerivationPath(e){var t;return!((t=this.metadata)===null||t===void 0)&&t.derivationPath?this.metadata.derivationPath:(await this.getWalletForAddress(e)).derivationPath}async getAddresses(){const{baseDerivationPath:e,derivationPathType:t}=this;try{return await this.trezor.connect(),(await(await this.trezor.getAccountManager()).getWallets(e,t)).map(a=>a.address)}catch(a){const r=a.message||"Unknown error",n=r.includes("Initialize")||r.includes("Handshake")||r.includes("Init_")?`Trezor connection failed: ${r}. Please ensure your Trezor device is connected, unlocked, and that pop-ups are allowed for this site.`:r;throw new v(new Error(n),{code:i,type:h.WalletError,contextModule:d.GetAccounts})}}async getAddressesInfo(){const{baseDerivationPath:e,derivationPathType:t}=this;try{return await this.trezor.connect(),(await(await this.trezor.getAccountManager()).getWallets(e,t)).map(a=>({address:a.address,derivationPath:a.derivationPath,baseDerivationPath:t}))}catch(a){const r=a.message||"Unknown error",n=r.includes("Initialize")||r.includes("Handshake")||r.includes("Init_")?`Trezor connection failed: ${r}. Please ensure your Trezor device is connected, unlocked, and that pop-ups are allowed for this site.`:r;throw new v(new Error(n),{code:i,type:h.WalletError,contextModule:d.GetAccounts})}}async getSessionOrConfirm(e){return Promise.resolve(`0x${S(F(`Confirmation for ${e} at time: ${Date.now()}`))}`)}async sendEvmTransaction(e,t){const a=await this.signEvmTransaction(e,t);try{return await(await this.getPublicClient(t.evmChainId)).sendRawTransaction({serializedTransaction:a})}catch(r){throw new v(new Error(r.message),{code:i,type:h.WalletError,contextModule:d.SendEvmTransaction})}}async sendTransaction(e,t){const{endpoints:a,txTimeout:r}=t;if(!a)throw new T(new Error("You have to pass endpoints.grpc within the options for using Ethereum native wallets"));const n=await new k(a.grpc).broadcast(e,{txTimeout:r});if(n.code!==0)throw new V(new Error(n.rawLog),{code:i,contextCode:n.code,contextModule:n.codespace});return n}async signEip712TypedData(e,t){const a=await P(),r=JSON.parse(e),{types:{EIP712Domain:n=[],...s}={},message:c={},domain:o={},primaryType:g,domain_separator_hash:l,message_hash:u}=de({...r,domain:{...r.domain,chainId:r.domain.chainId,salt:"0"}});try{await this.trezor.connect();const p=await this.getDerivationPath(t),I=await a.ethereumSignTypedData({path:p,data:{types:{EIP712Domain:n,...s},message:c,domain:o,primaryType:g},message_hash:u,domain_separator_hash:l,metamask_v4_compat:!0});if("code"in I.payload&&I.payload.code==="Failure_ActionCancelled")throw new Error("Request rejected");if(!I.success)throw new Error(I.payload&&I.payload.error||"Unknown error");return I.payload.signature}catch(p){throw new v(new Error(p.message),{code:i,type:h.WalletError,contextModule:d.SignTransaction})}}async signAminoCosmosTransaction(e){throw new T(new Error("This wallet does not support signing Cosmos transactions"),{code:i,type:h.WalletError,contextModule:d.SendTransaction})}async signCosmosTransaction(e){throw new T(new Error("This wallet does not support signing Cosmos transactions"),{code:i,type:h.WalletError,contextModule:d.SendTransaction})}async signArbitrary(e,t){const a=await P();try{await this.trezor.connect();const r=await this.getDerivationPath(e),n=await a.ethereumSignMessage({path:r,message:q(t)});if(!n.success)throw new Error(n.payload&&n.payload.error||"Unknown error");return n.payload.signature}catch(r){throw new v(new Error(r.message),{code:i,type:h.WalletError,contextModule:d.SignTransaction})}}async getEthereumChainId(){return(await(await this.getPublicClient()).getChainId()).toString()}async getEvmTransactionReceipt(e,t){const a=await this.getPublicClient(t);try{return await a.waitForTransactionReceipt({hash:e,timeout:3e4,pollingInterval:3e3}),e}catch{throw new Error(`Failed to retrieve transaction receipt for txHash: ${e}`)}}async getPubKey(){throw new T(new Error("You can only fetch PubKey from Cosmos native wallets"))}async signEvmTransaction(e,t){const a=await P(),r=parseInt(t.evmChainId.toString(),10),n=await this.getPublicClient(t.evmChainId),s=t.address.startsWith("0x")?t.address:`0x${t.address}`,c=await n.getTransactionCount({address:s}),o=y=>{if(typeof y=="string"){const C=y.startsWith("0x")?y:`0x${y}`;return BigInt(C)}return BigInt(y)},g=o(e.value||"0x0"),l=o(e.gas),u=o(e.maxFeePerGas),p=o(e.maxPriorityFeePerGas),I={to:e.to,value:f(g),gasLimit:f(l),nonce:f(c),data:e.data||"0x",chainId:r,maxFeePerGas:f(u),maxPriorityFeePerGas:f(p)};try{await this.trezor.connect();const y=await this.getDerivationPath(t.address),C=await a.ethereumSignTransaction({path:y,transaction:I});if(!C.success)throw new v(new Error(C.payload&&C.payload.error||"Something happened while signing with Trezor"),{code:i,type:h.WalletError,contextModule:d.SignEvmTransaction});return b({type:"eip1559",chainId:r,nonce:c,to:e.to,value:g,data:e.data||"0x",gas:l,maxFeePerGas:u,maxPriorityFeePerGas:p,v:BigInt(C.payload.v),r:C.payload.r,s:C.payload.s})}catch(y){throw y instanceof v?y:new v(new Error(y.message),{code:i,type:h.WalletError,contextModule:d.SignEvmTransaction})}}async getWalletForAddress(e){const{baseDerivationPath:t,derivationPathType:a}=this,r=await this.trezor.getAccountManager();if(!r.hasWalletForAddress(e)){for(let n=0;n<Q/A;n+=1)if(await r.getWallets(t,a),r.hasWalletForAddress(e))return await r.getWalletForAddress(e)}return await r.getWalletForAddress(e)}async getEip1193Provider(){var e;return new $e(this.trezor,{chainId:this.evmOptions.evmChainId.toString(),derivationPath:(e=this.metadata)===null||e===void 0?void 0:e.derivationPath})}async getPublicClient(e){var t;if(this.publicClient)return this.publicClient;const a=this.evmOptions,r=e||a.evmChainId,n=a.rpcUrl||((t=a.rpcUrls)===null||t===void 0?void 0:t[r]);if(!n)throw new ne(new Error("Please pass rpcUrl within the ethereumOptions"));return this.publicClient=x(r,n),this.publicClient}},Fe=class extends le{constructor(e){super({...e,derivationPathType:z.Bip32})}},Be=class extends le{constructor(e){super({...e,derivationPathType:z.Bip44})}};const Ne=Object.freeze(Object.defineProperty({__proto__:null,TrezorBip32Strategy:Fe,TrezorBip44Strategy:Be,TrezorDerivationPathType:z},Symbol.toStringTag,{value:"Module"}));export{Ne as a,Ke as i};
