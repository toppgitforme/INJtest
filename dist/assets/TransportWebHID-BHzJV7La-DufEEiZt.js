import{b as l,e as m,D as w,d as D}from"./lib-es-BdVxwK9Z-B9dpt8vi.js";import{l as h}from"./semver-DQp6anwM-IwHLRqB3.js";import{T as y,i as f,h as b,l as g}from"./lib-es-DZEyST3--mHrXDXPA.js";import{$ as I}from"./injective-utils-C9MYzl-J.js";import"./icons-Dj0zHVqu.js";const k=[{vendorId:g}],S=()=>Promise.resolve(!!(window.navigator&&window.navigator.hid)),a=()=>{const{hid:i}=navigator;if(!i)throw new m("navigator.hid is not supported","HIDNotSupported");return i};async function v(){const i=await a().requestDevice({filters:k});return Array.isArray(i)?i:[i]}async function p(){return(await a().getDevices()).filter(i=>i.vendorId===g)}async function x(){const i=await p();return i.length>0?i[0]:(await v())[0]}var B=class c extends y{device;deviceModel;channel=Math.floor(Math.random()*65535);packetSize=64;constructor(e){super(),this.device=e,this.deviceModel=typeof e.productId=="number"?f(e.productId):void 0,e.addEventListener("inputreport",this.onInputReport)}inputs=[];inputCallback;read=()=>this.inputs.length?Promise.resolve(this.inputs.shift()):new Promise(e=>{this.inputCallback=e});onInputReport=e=>{const t=I.Buffer.from(e.data.buffer);this.inputCallback?(this.inputCallback(t),this.inputCallback=null):this.inputs.push(t)};static isSupported=S;static list=p;static listen=e=>{let t=!1;x().then(n=>{if(!n)e.error(new l("Access denied to use Ledger device"));else if(!t){const o=typeof n.productId=="number"?f(n.productId):void 0;e.next({type:"add",descriptor:n,deviceModel:o}),e.complete()}},n=>{e.error(new l(n.message))});function r(){t=!0}return{unsubscribe:r}};static async request(){const[e]=await v();return c.open(e)}static async openConnected(){const e=await p();return e.length===0?null:c.open(e[0])}static async open(e){await e.open();const t=new c(e),r=n=>{e===n.device&&(a().removeEventListener("disconnect",r),t._emitDisconnect(new D))};return a().addEventListener("disconnect",r),t}_disconnectEmitted=!1;_emitDisconnect=e=>{this._disconnectEmitted||(this._disconnectEmitted=!0,this.emit("disconnect",e))};async close(){await this.exchangeBusyPromise,this.device.removeEventListener("inputreport",this.onInputReport),await this.device.close()}exchange=async e=>await this.exchangeAtomicImpl(async()=>{const{channel:t,packetSize:r}=this;h("apdu","=> "+e.toString("hex"));const n=b(t,r),o=n.makeBlocks(e);for(let s=0;s<o.length;s++)await this.device.sendReport(0,o[s]);let d,u;for(;!(d=n.getReducedResult(u));)try{const s=await this.read();u=n.reduceResponse(u,s)}catch(s){if(s instanceof m&&s.id==="InvalidChannel")continue;throw s}return h("apdu","<= "+d.toString("hex")),d}).catch(t=>{throw t&&t.message&&t.message.includes("write")?(this._emitDisconnect(t),new w(t.message)):t});setScrambleKey(){}};export{B as default};
